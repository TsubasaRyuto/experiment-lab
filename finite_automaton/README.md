# Finite Automaton

このディレクトリは、有限オートマトン（Finite Automaton）に関連する様々な実装や実験コードを集めたものです。主に決定性有限オートマトン（DFA）を中心に、関連するアルゴリズムやツールのコードを含んでいます。

## コンテンツ

### 1. 有限オートマトンの実験

**File**: `dfa_simple.py`

#### オートマトンの概要

以下の決定性有限オートマトン \( M \) を実装しました：

\[
M = (\{q1, q2\}, \{0, 1\}, δ, q1, \{q2\})
\]

- **状態集合** \( Q = \{q1, q2\} \)
- **アルファベット** \( Σ = \{0, 1\} \)
- **遷移関数** \( δ \) :
  - \( δ(q1, 0) -> q1 \)
  - \( δ(q1, 1) -> q2 \)
  - \( δ(q2, 0) -> q1 \)
  - \( δ(q2, 1) -> q2 \)
- **初期状態** \( q1 \)
- **受理状態** \( F = \{q2\} \)

#### テストケース

以下の文字列に対して、オートマトンの受理/不受理をテストしました。

| 入力 | 結果  |
|------|-------|
| '0'  | False (不受理) |
| '1'  | True (受理) |
| '01' | True (受理) |
| '00' | False (不受理) |
| '010101' | True (受理) |
| '0101010' | False (不受理) |

#### 結果

実験の結果、この有限オートマトンは以下の言語を受理することがわかりました：

\[
L(M) = \{ w | wは1で終わる \}
\]

このオートマトンは、与えられた入力が「1で終わる」場合に受理されることが確認されました。

---

### 2. 有限オートマトンの実験(偶数判定)

**File**: `even_judgement.py`

#### 問題
アルファベット{0, 1}として、文字列中に１を偶数個持つような文字列であるかを判定する有限オートマトンを設計・実装する。

#### 設計(思考)
状態としては「現時点の状態」が偶数なのか奇数なのか、

今回の問題は「文字列中に１を偶数個持つ」とあるので、入力が１の時のみ状態遷移をし、入力が０の時は状態をそのままにするようにすれば良い

それを踏まえて以下、オートマトンの概要

#### オートマトンの概要

以下の決定性有限オートマトン \( M \) を実装しました：

q1 = EVEN
q2 = ODD

\[
M = (\{q1, q2\}, \{0, 1\}, δ, q1, \{q2\})
\]

- **状態集合** \( Q = \{q1, q2\} \)
- **アルファベット** \( Σ = \{0, 1\} \)
- **遷移関数** \( δ \) :
  - \( δ(q1, 0) -> q1 \)
  - \( δ(q1, 1) -> q2 \) // ***1が入力されたら状態遷移***
  - \( δ(q2, 0) -> q2 \)
  - \( δ(q2, 1) -> q1 \) // ***1が入力されたら状態遷移***
- **初期状態** \( q1 \)
- **受理状態** \( F = \{q1\} \) // ***今回は偶数か否かを判定するのでq1を受理状態とする***

#### テストケース

以下の文字列に対して、オートマトンの受理/不受理をテストしました。

| 入力 | 結果  |
|------|-------|
| '0'  | True (受理) |
| '1'  | False (不受理) |
| '01' | False (不受理) |
| '00' | True (受理) |
| '010101' | False (不受理) |
| '0101011' | True (受理) |

---

### 3. 有限オートマトンの実験(文字列の[hoge]を判定)

**File**: `hoge_judgement.py`

#### 問題
アルファベット{a..z}として、入力された文字列のなかに[hoge]を持つ文字列かを判定する有限オートマトンを設計・実装する。

#### 設計(思考)
状態としては `h` / `o` / `g` / `e` / `other`を表現できればいよい。

今回の問題は「[hoge]を持つ文字列」とあるので、h -> o -> g -> e という順に文字列がなれんでいることを状態で管理できるようにする
もし、h -> aのように関係のないアルファベットが入力された段階で状態 `other`に戻る

それを踏まえて以下、オートマトンの概要

#### オートマトンの概要

以下の決定性有限オートマトン \( M \) を実装しました：

q1 = `other` (アルファベットhoge意外のアルファベット)
q2 = 'h'
q3 = 'o'
q4 = 'g'
q5 = 'e'

\[
M = (\{q1, q2, q3, q4, q5\}, \{a..z\}, δ, q1, \{q5\})
\]

- **状態集合** \( Q = \{q1, q2, q3, q4, q5\} \)
- **アルファベット** \( Σ = \{a..z\} \)
- **遷移関数** \( δ \) :
  - \( δ(q1, 'h') -> q2 \)
  - \( δ(q2, 'o') -> q3 \)
  - \( δ(q3, 'g') -> q4 \)
  - \( δ(q4, 'e') -> q5 \)
  - \( δ(q5, {a..z}) -> q5 \) // ***状態q5にいる段階でどのようなアルファベットが来ても受理状態は変わりない***
  - \( δ(qn, {a..z}) -> q1 \) // ***状態qn(n=1..5)に対して上記遷移関数の入力以外は初期状態に戻るようにする***
- **初期状態** \( q1 \)
- **受理状態** \( F = \{q5\} \)

#### テストケース

以下の文字列に対して、オートマトンの受理/不受理をテストしました。

| 入力 | 結果  |
|------|-------|
| 'hoge'  | True (受理) |
| 'hage'  | False (不受理) |
| 'hoga' | False (不受理) |
| 'abchdefoghigjkle' | False (不受理) |
| 'abchoagexyz' | False (不受理) |
| 'abchaogexyz' | False (不受理) |
| 'abchogexyz' | True (受理) |

---

### 4. 有限オートマトンのシミュレーター

**File**: `dfa_simulator.py`

#### 問題
言語を認識するDFAの設計をシミュレートできるようにする

#### 概要
DFA = (Q, Σ, δ, q0, F)とテストケースを入力値として受理するかしないかを返す
入力値は `./data/xxx.json` に追加し、DFAの各項目とテストケースを追加し、プログラムを実行することで、
設計したDFAがテストケースをすべて受理することができるか確認することができるようになっている。
（逆に受理しないパターンも確認すると良い）


#### 問題定義
このプログラムは、特定の言語を認識する有限オートマトン（DFA）の設計をシミュレートします。ユーザーは設計したDFAが指定されたテストケースに対して正しく動作するかどうかを検証できます。

#### 概要
有限オートマトンは、形式 `(Q, Σ, δ, q0, F)` で定義されます。ここで、
- `Q` は状態の集合、
- `Σ` はアルファベットの集合、
- `δ` は遷移関数、
- `q0` は開始状態、
- `F` は受理状態の集合です。

JSONファイル形式でこれらの要素とテストケースを指定し、プログラムはそれぞれのテストケースに対してDFAが受理するか否かを返します。
このプロセスを通じて、設計したDFAの正確性を検証することができます。

#### 入力データの形式
入力データは `./data/xxx.json` というファイルに保存します。このJSONファイルには以下の情報が含まれる必要があります：

```json
{
  "states": ["q0", "q1", "q2"],
  "alphabet_list": ["0", "1"],
  "transition_function": {
    "q0,0": "q1",
    "q0,1": "q0",
    ...
  },
  "start_state": "q0",
  "accept_states": ["q1"],
  "test_cases": ["000", "111", "001"]
}
```

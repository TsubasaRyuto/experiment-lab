# Finite Automaton

このディレクトリは、有限オートマトン（Finite Automaton）に関連する様々な実装や実験コードを集めたものです。主に決定性有限オートマトン（DFA）を中心に、関連するアルゴリズムやツールのコードを含んでいます。

## コンテンツ

### 1. 有限オートマトンの実験

**File**: `dfa_simple.py`

#### オートマトンの概要

以下の決定性有限オートマトン \( M \) を実装しました：

\[
M = (\{q1, q2\}, \{0, 1\}, δ, q1, \{q2\})
\]

- **状態集合** \( Q = \{q1, q2\} \)
- **アルファベット** \( Σ = \{0, 1\} \)
- **遷移関数** \( δ \) :
  - \( δ(q1, 0) -> q1 \)
  - \( δ(q1, 1) -> q2 \)
  - \( δ(q2, 0) -> q1 \)
  - \( δ(q2, 1) -> q2 \)
- **初期状態** \( q1 \)
- **受理状態** \( F = \{q2\} \)

#### テストケース

以下の文字列に対して、オートマトンの受理/不受理をテストしました。

| 入力 | 結果  |
|------|-------|
| '0'  | False (不受理) |
| '1'  | True (受理) |
| '01' | True (受理) |
| '00' | False (不受理) |
| '010101' | True (受理) |
| '0101010' | False (不受理) |

#### 結果

実験の結果、この有限オートマトンは以下の言語を受理することがわかりました：

\[
L(M) = \{ w | wは1で終わる \}
\]

このオートマトンは、与えられた入力が「1で終わる」場合に受理されることが確認されました。

---

### 2. 有限オートマトンの実験(偶数判定)

**File**: `even_judgement.py`

#### 問題
アルファベット{0, 1}として、文字列中に１を偶数個持つような文字列であるかを判定する有限オートマトンを設計・実装する。

#### 設計(思考)
状態としては「現時点の状態」が偶数なのか奇数なのか、

今回の問題は「文字列中に１を偶数個持つ」とあるので、入力が１の時のみ状態遷移をし、入力が０の時は状態をそのままにするようにすれば良い

それを踏まえて以下、オートマトンの概要

#### オートマトンの概要

以下の決定性有限オートマトン \( M \) を実装しました：

q1 = EVEN
q2 = ODD

\[
M = (\{q1, q2\}, \{0, 1\}, δ, q1, \{q2\})
\]

- **状態集合** \( Q = \{q1, q2\} \)
- **アルファベット** \( Σ = \{0, 1\} \)
- **遷移関数** \( δ \) :
  - \( δ(q1, 0) -> q1 \)
  - \( δ(q1, 1) -> q2 \) // ***1が入力されたら状態遷移***
  - \( δ(q2, 0) -> q2 \)
  - \( δ(q2, 1) -> q1 \) // ***1が入力されたら状態遷移***
- **初期状態** \( q1 \)
- **受理状態** \( F = \{q1\} \) // ***今回は偶数か否かを判定するのでq1を受理状態とする***

#### テストケース

以下の文字列に対して、オートマトンの受理/不受理をテストしました。

| 入力 | 結果  |
|------|-------|
| '0'  | True (受理) |
| '1'  | False (不受理) |
| '01' | False (不受理) |
| '00' | True (受理) |
| '010101' | False (不受理) |
| '0101011' | True (受理) |

---

### 3. 有限オートマトンの実験(文字列の[hoge]を判定)

**File**: `hoge_judgement.py`

#### 問題
アルファベット{a..z}として、入力された文字列のなかに[hoge]を持つ文字列かを判定する有限オートマトンを設計・実装する。

#### 設計(思考)
状態としては `h` / `o` / `g` / `e` / `other`を表現できればいよい。

今回の問題は「[hoge]を持つ文字列」とあるので、h -> o -> g -> e という順に文字列がなれんでいることを状態で管理できるようにする
もし、h -> aのように関係のないアルファベットが入力された段階で状態 `other`に戻る

それを踏まえて以下、オートマトンの概要

#### オートマトンの概要

以下の決定性有限オートマトン \( M \) を実装しました：

q1 = `other` (アルファベットhoge意外のアルファベット)
q2 = 'h'
q3 = 'o'
q4 = 'g'
q5 = 'e'

\[
M = (\{q1, q2, q3, q4, q5\}, \{a..z\}, δ, q1, \{q5\})
\]

- **状態集合** \( Q = \{q1, q2, q3, q4, q5\} \)
- **アルファベット** \( Σ = \{a..z\} \)
- **遷移関数** \( δ \) :
  - \( δ(q1, 'h') -> q2 \)
  - \( δ(q2, 'o') -> q3 \)
  - \( δ(q3, 'g') -> q4 \)
  - \( δ(q4, 'e') -> q5 \)
  - \( δ(q5, {a..z}) -> q5 \) // ***状態q5にいる段階でどのようなアルファベットが来ても受理状態は変わりない***
  - \( δ(qn, {a..z}) -> q1 \) // ***状態qn(n=1..5)に対して上記遷移関数の入力以外は初期状態に戻るようにする***
- **初期状態** \( q1 \)
- **受理状態** \( F = \{q5\} \)

#### テストケース

以下の文字列に対して、オートマトンの受理/不受理をテストしました。

| 入力 | 結果  |
|------|-------|
| 'hoge'  | True (受理) |
| 'hage'  | False (不受理) |
| 'hoga' | False (不受理) |
| 'abchdefoghigjkle' | False (不受理) |
| 'abchoagexyz' | False (不受理) |
| 'abchaogexyz' | False (不受理) |
| 'abchogexyz' | True (受理) |

---

### 4. 有限オートマトンのシミュレーター

**File**: `dfa_simulator.py`

#### 問題定義
このプログラムは、特定の言語を認識する有限オートマトン（DFA）の設計をシミュレートします。ユーザーは設計したDFAが指定されたテストケースに対して正しく動作するかどうかを検証できます。

#### 概要
有限オートマトンは、形式 `(Q, Σ, δ, q0, F)` で定義されます。ここで、
- `Q` は状態の集合、
- `Σ` はアルファベットの集合、
- `δ` は遷移関数、
- `q0` は開始状態、
- `F` は受理状態の集合です。

JSONファイル形式でこれらの要素とテストケースを指定し、プログラムはそれぞれのテストケースに対してDFAが受理するか否かを返します。
このプロセスを通じて、設計したDFAの正確性を検証することができます。

#### 入力データの形式
入力データは `./data/xxx.json` というファイルに保存します。このJSONファイルには以下の情報が含まれる必要があります：

```json
{
  "states": ["q0", "q1", "q2"],
  "alphabet_list": ["0", "1"],
  "transition_function": {
    "q0,0": "q1",
    "q0,1": "q0",
    ...
  },
  "start_state": "q0",
  "accept_states": ["q1"],
  "test_cases": ["000", "111", "001"]
}
```

---

### 5. NFAからDFAに変換するプログラム

**File**: `nfa_to_dfa_converter.py`

#### 概要
与えられた非決定性有限オートマトン（NFA）から決定性有限オートマトン（DFA）に変換するプログラムを実装しました。
今回の実装では、テスト(`nfa_to_dfa_converter.test.py`)の実装を行い、与えられたNFAがDFAに変換できることを確認できるようになっています。

具体的には、NFA の状態と遷移を解析し、DFA の各状態に対応する部分集合を生成して、最終的な DFA の状態の集合、状態遷移、開始状態、受理状態を返します。

テスト (`nfa_to_dfa_converter.test.py`) も実装されており、複数の NFA を入力して、その変換結果が期待される DFA と一致することを確認しています。このテストにより、変換が正しく行われていることを保証します。
テストコードをみて変換後の戻り値がどのような状態で返って来るかも確認できます。

testの実行は `python3 nfa_to_dfa_converter.test.py` を実行してください。

---
